<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body></body>
  <script>

    function twoSum(nums, target) {
      const len = nums.length;
      const map = new Map();
      let tar = '';
      for (let i = 0; i < len; i++) {
        tar = target - nums[i];
        if (map.has(tar)) {
          return [map.get(tar), i];
        }
        map.set(nums[i], i);
      }
    }
    // twoSum([3,2,4], 7);

    function reverse(x) {
      let result = 0;
      let value = Math.abs(x);
      const MAX_VALUE = Math.pow(2, 31) - 1;
      const MIN_VALUE = -Math.pow(2, 31);
      while (value !== 0) {
        let next = value % 10;
        if (result > MAX_VALUE / 10 || (result === Math.floor(MAX_VALUE / 10) && next > 7)) {
          return 0;
        }
        if (result < MIN_VALUE / 10 || (result === Math.floor(MAX_VALUE / 10) && next < -8)) {
          return 0;
        }
        result = result * 10 + next;
        value = Math.floor(value / 10);
      }
      result = x >= 0 ? result : -result;
      return result;
    }
    // console.log(reverse(-213333333));

    function isPalindrome(x) {
      if (x < 0) {
        return false;
      }
      if (x === 0) {
        return true;
      }
      let result = 0;
      let value = x;
      while (value !== 0) {
        result = result * 10 + (value % 10);
        value = Math.floor(value / 10);
      }
      return result === x;
    }

    function romanToInt(x) {
      const obj = {
        I: 1,
        V: 5,
        X: 10,
        L: 50,
        C: 100,
        D: 500,
        M: 1000,
      };
      let arr = x.split('');
      let result = arr.reduce((sum, currentValue, currentIndex, array) => {
        if (obj[currentValue] < obj[array[currentIndex + 1]]) {
          return sum - obj[currentValue];
        }
        return sum + obj[currentValue];
      }, 0);
      return result;
    }
    // console.log(romanToInt('MCMXCIV'));

    function longestCommonPrefix(strs) {
      let lenArr = strs.map((item) => item.length);
      let short = Math.min(...lenArr);
      // 找出最短项的长度
      if (short === Infinity) {
        return '';
      }
      let i = 0;
      while (i < short) {
        // 横向取出第一个字符，不唯一就跳出
        let set = new Set(strs.map((item) => item[i]));
        if (set.size !== 1) {
          break;
        }
        i++;
      }
      return strs[0].slice(0, i);
    }
    // console.log(longestCommonPrefix([]));

    function isValid(str) {
      const obj = {
        '(': ')',
        '[': ']',
        '{': '}',
      };
      let strArr = str.split(''),
        result = [];
      while (strArr.length) {
        let topItem = strArr.shift();
        if (obj[topItem]) {
          result.push(topItem);
          continue;
        } else {
          if (obj[result.pop()] != topItem) {
            return false;
          }
        }
      }
      return result.length ? false : true;
    }
    // console.log(isValid("()[(){()}{{}}()]"));

    function myPow(x, n) {
      if (x === 0) {
        return 0;
      }
      if (x === 1) {
        return 1;
      }
      if (x === -1) {
        return n % 2 ? -1 : 1;
      }
      if (n === 0) {
        return 1;
      }
      function result(x, n) {
        n = Math.abs(n);
        if (n === 1) {
          return x;
        }
        let half = result(x, Math.floor(n / 2));
        return half * half * (n % 2 ? x : 1);
      }
      if (n > 0) {
        return result(x, n);
      }
      return 1 / result(x, n);
    }
    // console.log(myPow(3, 5));

    class MyCircularQueue {
      constructor(k) {
        this.arr = [];
        this.len = k;
        this.first = 0;
        this.last = 0;
      }
      Front() {
        if (this.isEmpty()) {
          return -1;
        }
        return this.arr[this.first];
      }
      Rear() {
        if (this.isEmpty()) {
          return -1;
        }
        return this.arr[this.last === 0 ? this.len - 1 : this.last - 1];
      }
      enQueue(value) {
        if (this.isFull()) {
          return false;
        } else {
          this.arr[this.last] = value;
          this.last = (this.last + 1) % this.len;
          return true;
        }
      }
      deQueue() {
        if (this.isEmpty()) {
          return false;
        } else {
          this.arr[this.first] = undefined;
          this.first = (this.first + 1) % this.len;
          return true;
        }
      }
      isEmpty() {
        if (this.first === this.last && !this.arr[this.first]) {
          return true;
        } else {
          return false;
        }
      }
      isFull() {
        if (this.first === this.last && this.arr[this.last]) {
          return true;
        } else {
          return false;
        }
      }
    }

    class MinStack {
      constructor() {
        this.arr = [];
        this.len = 0;
      }
      isEmpty() {
        return this.len === 0;
      }
      push(x) {
        if (this.isEmpty()) {
          this.arr.push({
            value: x,
            min: x,
          });
          this.len++;
        } else {
          let min = x < this.arr[this.len - 1].min ? x : this.arr[this.len - 1].min;
          this.arr.push({
            value: x,
            min: min,
          });
          this.len++;
        }
      }
      pop() {
        if (this.isEmpty()) {
          return;
        }
        this.arr.pop();
        this.len--;
      }
      top() {
        if (this.isEmpty()) {
          return;
        }
        return this.arr[this.len - 1].value;
      }
      getMin() {
        if (this.isEmpty()) {
          return;
        }
        return this.arr[this.len - 1].min;
      }
    }

    function numIslands(grid) {
      if (!grid || !grid.length) {
        return 0;
      }
      let nr = grid.length,
        nc = grid[0].length,
        num = 0;
      for (let r = 0; r < nr; r++) {
        for (let c = 0; c < nc; c++) {
          if (grid[r][c] === '1') {
            grid[r][c] = 0;
            num++;
            let queue = [];
            queue.push({
              r,
              c,
            });
            while (queue.length) {
              let item = queue.shift(),
                row = item.r,
                col = item.c;
              if (row - 1 >= 0 && grid[row - 1][col] === '1') {
                grid[row - 1][col] = 0;
                queue.push({
                  r: row - 1,
                  c: col,
                });
              }
              if (row + 1 < nr && grid[row + 1][col] === '1') {
                grid[row + 1][col] = 0;
                queue.push({
                  r: row + 1,
                  c: col,
                });
              }
              if (col - 1 >= 0 && grid[row][col - 1] === '1') {
                grid[row][col - 1] = 0;
                queue.push({
                  r: row,
                  c: col - 1,
                });
              }
              if (col + 1 < nc && grid[row][col + 1] === '1') {
                grid[row][col + 1] = 0;
                queue.push({
                  r: row,
                  c: col + 1,
                });
              }
            }
          }
        }
      }
      return num;
    }

    // function openLock(deadends, target) {
    //   if (target === '0000') {
    //     return 0;
    //   }
    //   if (deadends.includes('0000')) {
    //     return -1;
    //   }
    //   let num = 0,
    //   queue = [target];
    //   set = new Set(deadends);

    //   while (queue.length) {
    //   	// 记录每轮的长度
    //   	let inLength = queue.length;
    //   	while (inLength) {
    //   		inLength--;
    //    	let tarArr = queue.shift().split('').map(item => parseInt(item));
    //      if (tarArr.join('') === '0000') {
    //      	return num;
    //      }
    //      for(let i = 0; i < 4; i++){
    //        let strLeft = '',
    //        strRight = ''
    //        strLeft = tarArr.map((item, index) => {
    //          return index === i ? (item===0?9:item - 1) : item;
    //        }).join('');
    //        if (!set.has(strLeft)) {
    //        	queue.push(strLeft);
    //        	set.add(strLeft);
    //        }
    //        strRight = tarArr.map((item, index) => {
    //          return index === i ? (item===9?0:item + 1) : item;
    //        }).join('');
    //        if (!set.has(strRight)) {
    //        	queue.push(strRight);
    //        	set.add(strRight);
    //        }
    //      }
    //   	}
    //   	num++;
    //   }
    //   return -1;
    // }

    var openLock = function (deadends, target) {
      deadends.push(target);
      let vds = [0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0];
      let stepLength = 0;
      let cashArr = [];
      while (target != '0000') {
        for (var i = 0; i < vds.length - 3; i++) {
          let tepStr = '';
          for (var j = 0; j < target.length; j++) {
            if (target[j] == 0 && vds[j + i] != 0) {
              tepStr = '';
              break;
            }
            tepStr += (+target[j] > 4 ? +target[j] - vds[j + i] : +target[j] + vds[j + i]) % 10;
          }
          if (!deadends.includes(tepStr) && tepStr) {
            target = tepStr;
            stepLength++;
            break;
          } else {
            cashArr.push(target);
            if (cashArr.filter((item) => item == target).length == 8) {
              return -1;
            }
          }
        }
      }
      return stepLength;
    };
    // console.log(openLock(['0201', '0101', '0102', '1212', '2002'], '0202'));

    function numSquares(n) {
      let queue = [n]
      num = 0
      set = new Set(queue);
      while (queue.length) {
        num++;
        let len = queue.length;
        while (len) {
          len--;
          let i = 1,
          sum = queue.shift();
          while (i**2 <= sum) {
            let k = sum - i**2;
            if (k === 0) {
              return num;
            }
            if (!set.has(k)) {
              queue.push(k);
              set.add(k);
            }
            i++;
          }
        }
      }
    }
    // console.log(numSquares(7168));

    function isValid2(s) {
      if (!s) {
        return true;
      }
      let sArr = s.split(''),
      stack = []
      obj = {
        '(': ')',
        '{': '}',
        '[': ']',
      };
      while (sArr.length) {
        let item = sArr.shift();
        if (!obj[item]) {
          let left = stack.pop();
          if (obj[left] !== item) {
            return false;
          }
        } else {
          stack.push(item);
        }
      }
      return stack.length ? false : true;
    }
    // console.log(isValid2('()()()'))

    function dailyTemperatures(T) {
      let tem = T,
      len = tem.length,
      result = new Array(len).fill(0),
      stack = [];
      for (let i = 0; i < len; i++) {
        while (stack.length && tem[i] > tem[stack[stack.length - 1]]) {
          let lastI = stack.pop();
          result[lastI] = i - lastI;
        }
        stack.push(i);
      }
      return result;
    }
    // dailyTemperatures([73, 74, 75])

    function singleNumber(nums) {
      let result = 0;
      for (let i = 0; i < nums.length; i++) {
        result = result^nums[i];
      }
      return result;
    }

    function evalRPN(tokens) {
      let result = [],
      last = 0,
      last2 = 0,
      top = 0;
      while (tokens.length) {
        top = tokens.shift();
        switch (top) {
          case '+':
            result.push(result.pop() + result.pop());
            break;
          case '-':
            last = result.pop();
            last2 = result.pop();
            result.push(last2 - last);
            break;
          case '*':
            result.push(result.pop() * result.pop());
            break;
          case '/':
            last = result.pop();
            last2 = result.pop();
            result.push(parseInt(last2 / last));
            break;
          default:
            result.push(parseInt(top));
            break;
        }
      }
      return result[0];
    }

    function cloneGraph(node) {
      let nodeLen = node.length,
      result = [];
      for (let i = 0; i < nodeLen; i++) {
        for (let j = 0; j < node[i].length; j++) {
          if (result[node[i][j] - 1]) {
            result[node[i][j] - 1].push(i + 1);
            continue;
          }
          result[node[i][j] - 1] = [i + 1];
        }
      }
      console.log(result);
      return result;
    }
    // cloneGraph([[2,4],[1,3],[2,4],[1,3]]);

    function findTargetSumWays (nums, S) {
      let result = 0,
      len = nums.length;
      function sum (nums, i, frontSum, S) {
        if (i === len) {
          if (frontSum === S) {
            result++;
          }
        } else {
          sum(nums, i + 1, frontSum + nums[i], S);
          sum(nums, i + 1, frontSum - nums[i], S);
        }
      }
      sum(nums, 0, 0, S);
      return result;
    }
    // findTargetSumWays([1, 1, 1, 1, 1], 3)

    class MyQueue {
      constructor() {
        this.arr = [];
      }
      push(value) {
        this.arr.push(value);
      }
      pop() {
        return this.arr.shift();
      }
      peek() {
        return this.arr[0];
      }
      empty() {
        return this.arr.length ? false : true;
      }
    }
    class MyStack {
      constructor() {
        this.arr = [];
      }
      push(value) {
        this.arr.push(value);
      }
      pop() {
        return this.arr.pop();
      }
      top() {
        return this.arr[this.arr.length - 1];
      }
      empty() {
        return this.arr.length ? false : true;
      }
    }

    function decodeString(s) {
      let reg = /(\d+)\[([^\[\]]+)\]/g;
      console.log(s.replace(reg, (match, p1, p2) => {
        console.log(p1, p2);
        return p2.repeat(p1);
      }));
      return;
      let strArr = s.match(/\d+|\[|\]|[a-zA-Z]+/g) || [],
      numReg = /\d+/,
      stack = [],
      result = '';
      while (strArr.length) {
        let first = strArr.shift();
        if (numReg.test(first)) {
          stack.push(first);
        } else if (first === '[') {
          stack.push(first);
        } else if (first === ']') {
          let last = stack.pop(),
          last2 = stack.pop(),
          last3 = stack.pop();
          if (!stack.length) {
            result += last.repeat(last3);
          } else {
            if (stack[stack.length - 1] === '[') {
              stack.push(last.repeat(last3));
            } else {
              stack.push(stack.pop() + last.repeat(last3));
            }
          }
        } else {
          if (!stack.length) {
            result += first;
          } else {
            if (stack[stack.length - 1] === '[') {
              stack.push(first);
            } else {
              stack.push(stack.pop() + first);
            }
          }
        }
      }
      return result;
    }
    // decodeString('2[2[2[a]]]')

    function maxProduct(nums) {
      // for (let i = 0; i < len; i++) {
      //   let max = nums[i];
      //   result = max > result ? max : result;
      //   for (let j = i + 1; j < len; j++) {
      //     max = max*nums[j]
      //     result = max > result ? max : result;
      //   }
      // }
      let len = nums.length,
      result = nums[0],
      frontMax = nums[0],
      frontMin = nums[0];
      for (let i = 1; i < len; i++) {
        let max = frontMax*nums[i],
        min = frontMin*nums[i];
        frontMax = Math.max(max, min, nums[i]);
        frontMin = Math.min(max, min, nums[i]);
        result = Math.max(result, frontMax);
      }
      return result;
    }

    // console.log(maxProduct([-2,3,-4]));

    // function updateMatrix (matrix) {
    //   let columnLen = matrix[0].length,
    //   rowLen = matrix.length
    //   result = [];
    //   for(let rn = 0; rn < rowLen; rn++) {
    //     result.push([]);
    //   }
    //   for(let rn = 0; rn < rowLen; rn++) {
    //     for(let cn = 0; cn < columnLen; cn++) {
    //       if (result[rn][cn] != undefined) {
    //         continue;
    //       }
    //       if (matrix[rn][cn] === 0) {
    //         result[rn][cn] = 0;
    //         continue;
    //       }
    //       let queue = [{
    //         rn,
    //         cn
    //       }];
    //       while (queue.length) {
    //         let item = queue.shift(),
    //         r = item.rn,
    //         c = item.cn;
    //         if (r - 1 >= 0) {
    //           if (matrix[r-1][c] === 0) {
    //             result[r-1][c] = 0;
    //             result[rn][cn] = Math.abs(r-1-rn) + Math.abs(c-cn);
    //             break;
    //           } else {
    //             queue.push({
    //               rn: r-1,
    //               cn: c
    //             })
    //           }
    //         }
    //         if (r + 1 < rowLen) {
    //           if (matrix[r+1][c] === 0) {
    //             result[r+1][c] = 0;
    //             result[rn][cn] = Math.abs(r+1-rn) + Math.abs(c-cn);
    //           break;
    //           } else {
    //             queue.push({
    //               rn: r+1,
    //               cn: c
    //             })
    //           }
    //         }
    //         if (c - 1 >= 0) {
    //           if (matrix[r][c-1] === 0) {
    //             result[r][c-1] = 0;
    //             result[rn][cn] = Math.abs(r-rn) + Math.abs(c-1-cn);
    //             break;
    //           } else {
    //             queue.push({
    //               rn: r,
    //               cn: c-1
    //             })
    //           }
    //         }
    //         if (c + 1 < columnLen) {
    //           if (matrix[r][c+1] === 0) {
    //             result[r][c+1] = 0;
    //             result[rn][cn] = Math.abs(r-rn) + Math.abs(c+1-cn);
    //             break;
    //           } else {
    //             queue.push({
    //               rn: r,
    //               cn: c+1
    //             })
    //           }
    //         }
    //       }
    //     }
    //   }
    //   console.log(matrix, result);
    //   return result;
    // }

    function updateMatrix (matrix) {
      let rowLen = matrix.length,
      columnLen = matrix[0].length,
      result = [],
      queue = [];
      for(let i = 0; i < rowLen; i++) {
        result.push([]);
        for (let j = 0; j < columnLen; j++) {
          if (matrix[i][j] === 0) {
            queue.push({
              r: i,
              c: j
            })
            result[i][j] = 0;
          }
        }
      }
      let level = 0;
      while (queue.length) {
        level++;
        let len = queue.length;
        while (len) {
          len--;
          let item = queue.shift(),
          r = item.r,
          c = item.c;
          if (r - 1 >= 0 && matrix[r-1][c] === 1) {
            result[r-1][c] = level;
            matrix[r-1][c] = 0;
            queue.push({
              r: r-1,
              c
            })
          }
          if (r + 1 < rowLen && matrix[r+1][c] === 1) {
            result[r+1][c] = level;
            matrix[r+1][c] = 0;
            queue.push({
              r: r+1,
              c
            })
          }
          if (c - 1 >= 0 && matrix[r][c-1] === 1) {
            result[r][c-1] = level;
            matrix[r][c-1] = 0;
            queue.push({
              r,
              c: c-1
            })
          }
          if (c + 1 <= columnLen && matrix[r][c+1] === 1) {
            result[r][c+1] = level;
            matrix[r][c+1] = 0;
            queue.push({
              r,
              c: c+1
            })
          }
        }
      }
      console.log(matrix,result);
      return result;
    }
    // updateMatrix([[0,0,0],[0,1,0],[1,1,1]]);

    function validPalindrome (s) {
      let left = 0,
      right = s.length - 1;
      while (left < right) {
        if (s[left] === s[right]) {
          left++;
          right--;
          continue;
        }
        return valid(s.slice(left+1, right+1)) || valid(s.slice(left, right));
      }
      function valid (s) {
        let left = 0,
        right = s.length - 1;
        while (left < right) {
          if (s[left]!=s[right]) {
            return false;
          }
          left++;
          right--;
        }
        return true;
      }
      return true;
    }

    // console.log(validPalindrome('abccaba'))

    function canVisitAllRooms (rooms) {
      let resultSet = new Set([0]);
      let queue = rooms[0];
      while (queue.length) {
        let room = queue.shift();
        if (resultSet.has(room)) {
          continue;
        }
        queue = queue.concat(rooms[room]);
        resultSet.add(room);
      }
      console.log(resultSet);
      return resultSet.size === rooms.length;
    }

    // canVisitAllRooms([[1],[2],[3],[]]);

    function pivotIndex (nums) {
      let len = nums.length;
      if (!len) {
        return -1;
      }
      let middle = 0,
      sumLeft = 0,
      sumRight = nums.reduce((a, b) => a + b) - nums[0];
      while (middle < len) {
        if (sumLeft === sumRight) {
          return middle;
        }
        sumLeft += nums[middle];
        sumRight -= nums[middle+1];
        middle++;
      }
      return -1;
    }

    function dominantIndex (nums) {
      let maxNum = Math.max(...nums),
      resultIndex = nums.indexOf(maxNum);
      nums.splice(resultIndex, 1);
      let maxNum2 = Math.max(...nums);
      if (maxNum >= maxNum2*2) {
        return resultIndex;
      }
      return -1;
    }
    // dominantIndex([0,0,0,1])

    function plusOne (digits) {
      digits.unshift(0);
      for (let i = digits.length - 1; i >= 0; i--) {
        digits[i] += 1;
        if (digits[i] < 10) {
          break;
        }
        digits[i] = digits[i] % 10;
      }
      if (digits[0] === 0) {
        digits.shift();
      }
      return digits;
    }
    // console.log(plusOne([1,2,3]))

    function findDiagonalOrder (matrix) {
      let m = matrix.length;
      if (!m) {
        return [];
      }
      let n = matrix[0].length;
      if (!n) {
        return [];
      }
      let i = 0,
      j = 0,
      result = [],
      direct = [-1, 1];
      while (result.length < m*n) {
        result.push(matrix[i][j]);
        i += direct[0];
        j += direct[1];

        if (i < 0 || j >= n) {
          direct = [1, -1];
          if (j >= n) {
            i += 2;
            j -= 1;
          } else {
            i += 1;
          }
        }
        if (j < 0 || i >= m) {
          direct = [-1, 1];
          if (i >= m) {
            j += 2;
            i -= 1;
          } else {
            j += 1;
          }
        }
      }
      return result;
    }
    // console.log(findDiagonalOrder([[1,2,3],[4,5,6],[7,8,9]]));


    function spiralOrder (matrix) {
      let m = matrix.length;
      if (!m) {
        return [];
      }
      let n = matrix[0].length;
      if (!n) {
        return [];
      }
      let i = 0,
      j = 0,
      topBorder = 0,
      rightBorder = n,
      bottomBorder = m,
      leftBorder = 0,
      result = [],
      direct = [
        [0, 1],
        [1, 0],
        [0, -1],
        [-1, 0]
      ],
      d = 0;
      while (result.length < m*n) {
        result.push(matrix[i][j]);
        switch (d) {
          case 0:
            if (j+1 >= rightBorder) {
              d++;
              i++;
              topBorder++;
              break;
            }
            j++;
            break;
          case 1:
            if (i+1 >= bottomBorder) {
              d++;
              j--;
              rightBorder--;
              break;
            }
            i++;
            break;
          case 2:
            if (j-1 < leftBorder) {
              d++;
              i--;
              bottomBorder--;
              break;
            }
            j--;
            break;
          case 3:
            if (i-1 < topBorder) {
              d = 0;
              j++;
              leftBorder++;
              break;
            }
            i--;
            break;
          default:
            break;
        }
      }
      return result;
    }
    // spiralOrder([
    //   [1, 2, 3, 4],
    //   [5, 6, 7, 8],
    //   [9,10,11,12]
    // ]);

    function generate (numRows) {
      if (numRows === 0) {
        return [];
      }
      if (numRows === 1) {
        return [[1]];
      }
      let result = [[1]];
      for (let i = 1; i < numRows; i++) {
        result.push([]);
        let left = [0, ...result[i-1]];
        let right = [...result[i-1], 0];
        for (let j = 0; j < left.length; j++) {
          result[i][j] = left[j] + right[j];
        }
      }
      return result;
    }
    // console.log(generate(5));

    function addBinary (a, b) {
      let aArr = a.split('').map(item => parseInt(item)),
      bArr = b.split('').map(item => parseInt(item)),
      aLen = aArr.length,
      bLen = bArr.length,
      result = [],
      k = 0,
      len = 0;
      if (aLen > bLen) {
        bArr = new Array(aLen - bLen).fill(0).concat(bArr);
        len = aLen;
      } else {
        aArr = new Array(bLen - aLen).fill(0).concat(aArr);
        len = bLen;
      }
      for (let i = len - 1; i >= 0; i--) {
        let sum = aArr[i] + bArr[i] + k;
        switch (sum) {
          case 0:
            result[i] = 0;
            break;
          case 1:
            result[i] = 1;
            k = 0;
            break;
          case 2:
            result[i] = 0;
            k = 1;
            break;
          case 3:
            result[i] = 1;
            k = 1;
            break;
          default:
            break;
        }
      }
      if (k != 0) {
        result.unshift(k);
      }
      return result.join('');
    }
    // console.log(addBinary('1010', '1111'));

    function strStr (haystack, neddle) {
      if (!neddle) {
        return 0;
      }
      let l = neddle.length,
      nl = haystack.length;
      if (nl < l) {
        return -1
      }
      for (let i = 0; i <= nl - l; i++) {
        if (haystack.slice(i, i+l) === neddle) {
          return i;
        }
      }
      return -1;
    }
    // console.log(strStr('a', 'a'))

    function reverseString (s) {
      let i = 0,
      j = s.length - 1;
      while (i < j) {
        [s[i], s[j]] = [s[j], s[i]];
        i++;
        j--;
      }
    }

    function arrayPairSum (nums) {
      nums.sort((a, b) => a - b);
      let sum = 0;
      for (let i = 0; i < nums.length / 2; i++) {
        sum += nums[2*i];
      }
      return sum;
    }

    function longestPalindrome (s) {
      function palind (s) {
        return s === s.split('').reverse().join('');
      }
      if (!s) {
        return '';
      }
      if (palind(s)) {
        return s;
      }
      let a = longestPalindrome(s.slice(0, s.length-1));
      let b = longestPalindrome(s.slice(1, s.length));
      return a.length > b.length ? a : b;
    }
    // console.log(longestPalindrome(""))

    function twoSum (numbers, target) {
      let i = 0,
      j = numbers.length - 1;
      while (i < j) {
        if (numbers[i] + numbers[j] < target) {
          i++;
          continue;
        }
        if (numbers[i] + numbers[j] > target) {
          j--;
          continue;
        }
        return [i+1, j+1];
      }
      return [];
    }
    // console.log(twoSum([2,7,11,15], 18))

    function removeElement (nums, val) {
      let len = nums.length, k = 0;
      for (let i = 0; i < len; i++) {
        if (nums[i] != val) {
          nums[k] = nums[i];
          k++;
        }
      }
      return k;
    }

    function findMaxConsecutiveOnes (nums) {
      let len = nums.length, i = 0, j = 0, result = 0;
      while (i < len) {
        if (nums[i] === 1) {
          j++;
        } else {
          result = result > j ? result : j;
          j = 0;
        }
        i++;
      }
      result = result > j ? result : j;
      return result;
    }
    // console.log(findMaxConsecutiveOnes([1,1,0,1,1,1]));

    function minSubArrayLen (s, nums) {
      let len = nums.length,
      sum = 0,
      j = 0,
      result = Infinity;
      for (let i = 0; i < len; i++) {
        sum += nums[i];
        while (sum >= s) {
          result = result < i+1 - j ? result : i+1 - j;
          sum = sum - nums[j];
          j++;
        }
      }
      return result === Infinity ? 0 : result;
    }
    // minSubArrayLen(7, [2,3,1,2,4,3]);

    function rotate (nums, k) {
      let len = nums.length,
      i = len - 1;
      while (i >= 0) {
        nums[i + k] = nums[i];
        i--;
      }
      while (k > 0) {
        nums[k - 1] = nums[len - 1 + k];
        k--;
      }
      nums.length = len;
    }

    function getRow (rowIndex) {
      if (rowIndex === 0) {
        return [1];
      }
      const result = [1];
      for (let i = 1; i <= rowIndex; i++) {
        result.unshift(0);
        for (let j = 0; j < result.length - 1; j++) {
          result[j] = result[j] + result[j + 1];
        }
      }
      return result;
    }

    function reverseWords (s) {
      const arr = s.trim().split(/\s+/);
      let i = 0,
      j = arr.length - 1;
      while (i < j) {
        [arr[i], arr[j]] = [arr[j], arr[i]];
        i++;
        j--;
      }
      return arr.join(' ');
    }

    function reverseWords (s) {
      const arr = s.split(' ');
      for(let i = 0, length1 = arr.length; i < length1; i++){
        arr[i] = arr[i].split('').reverse().join('');
      }
      return arr.join(' ');
    }
    // reverseWords("Let's take LeetCode contest");

    function removeDuplicates (nums) {
      let i = nums.length - 1;
      while (i > 0) {
        if (nums[i] === nums[i - 1]) {
          nums.splice(i, 1);
        }
        i--;
      }
    }

    function moveZeroes (nums) {
      let i = nums.length - 1;
      while (i >= 0) {
        if (nums[i] === 0) {
          nums.splice(i, 1);
          nums.push(0);
        }
        i--;
      }
    }
    function moveZeroes (nums) {
      let i = 0, j = 0;
      let length1 = nums.length;
      while (i < length1) {
        if (nums[i] === 0) {
          i++;
          continue;
        }
        [nums[j], nums[i]] = [nums[i], nums[j]];
        j++;
        i++;
      }
      console.log(nums);
    }
    // moveZeroes([0,1,0,3,12]);


    class Node {
      constructor(val) {
        this.val = val;
        this.next = null;
      }
    }
    class MyLinkedList {
      constructor() {
        this.head = {
          next: null
        };
        this.len = 0;
      }
      static createNode(val) {
        return new Node(val);
      }
      addAtHead(val) {
        this.addAtIndex(0, val);
      }
      addAtTail(val) {
        this.addAtIndex(this.len, val);
      }
      addAtIndex(index, val) {
        if (index > this.len) {
          return;
        }
        let newNode = MyLinkedList.createNode(val),
        node = this.head,
        i = 0;
        while (i < index) {
          node = node.next;
          i++;
        }
        newNode.next = node.next;
        node.next = newNode;
        this.len++;
      }
      get(index) {
        if (index >= this.len) {
          return -1;
        }
        let node = this.head,
        i = 0;
        while (i <= index) {
          node = node.next;
          i++;
        }
        return node.val;
      }
      deleteAtIndex(index) {
        if (index >= this.len || index < 0) {
          return;
        }
        let node = this.head,
        i = 0;
        while (i < index) {
          node = node.next;
          i++;
        }
        node.next = node.next.next;
        this.len--;
      }
    }
    let linkedList = new MyLinkedList();
    linkedList.addAtHead(1);
    // linkedList.addAtTail(2);
    // linkedList.addAtTail(1);
    // linkedList.addAtTail(5);
    // linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
    // linkedList.get(1);            //返回2
    // linkedList.deleteAtIndex(1);  //现在链表是1-> 3
    // linkedList.get(1);            //返回3
    console.log(linkedList);

    function hasCycle (head) {
      if (!head) {
        return false;
      }
      if (!head.next) {
        return false;
      }
      let nodeI = head, nodeJ = head.next.next;
      while (nodeJ && nodeJ.next) {
        nodeI = nodeI.next;
        nodeJ = nodeJ.next.next;
        if (nodeI === nodeJ) {
          return true;
        }
      }
      return false;
    }

    function detectCycle (head) {
      if (!head) {
        return null;
      }
      if (!head.next) {
        return null;
      }
      let nodeI = head, nodeJ = head;
      while (nodeJ && nodeJ.next) {
        nodeI = nodeI.next;
        nodeJ = nodeJ.next.next;
        if (nodeI === nodeJ) {
          nodeJ = head;
          while (nodeI != nodeJ) {
            nodeJ = nodeJ.next;
            nodeI = nodeI.next;
          }
          return nodeI;
        }
      }
      return null;
    }
    // console.log(detectCycle(linkedList));

    function getIntersectionNode (headA, headB) {
      let nodeA = headA,
      nodeB = headB,
      i = 0;
      while (nodeA && nodeB && i < 3) {
        if (nodeA === nodeB) {
          return nodeA;
        }
        nodeA = nodeA.next;
        nodeB = nodeB.next;
        //  两个链表长度加起来 一样长，真的秀
        if (!nodeA) {
          nodeA = headB;
          i++;
        }
        if (!nodeB) {
          nodeB = headA;
          i++;
        }
      }
      return null;
    }

    function removeNthFromEnd (head, n) {
      let fast = head,
      slow = head,
      i = 1;
      if (!fast.next) {
        return null;
      }
      while (i <= n) {
        fast = fast.next;
        i++;
      }
      if (!fast) {
        head = slow.next;
        return head;
      }
      while (fast.next) {
        fast = fast.next;
        slow = slow.next;
      }
      slow.next = slow.next.next;
      return head;



      // let nodePre = head,
      // nodeNext = head.next,
      // i = 0;
      // if (!nodeNext) {
      //   return null;
      // }
      // while (nodeNext) {
      //   nodeNext.pre = nodePre;
      //   nodePre = nodeNext;
      //   nodeNext = nodeNext.next;
      // }
      // while (i < n) {
      //   i++;
      //   if (!nodePre.pre) {
      //     head = nodePre.next;
      //     break;
      //   }
      //   nodePre = nodePre.pre;
      // }
      // if (nodePre.next) {
      //   nodePre.next = nodePre.next.next;
      // } else {
      //   head = null;
      // }
      // return head;
    }
    // console.log(removeNthFromEnd(linkedList.head.next, 2));


    function reverseList (head) {



      let currentNode = head,
      pre = null;
      while (currentNode) {
        const next = currentNode.next;
        currentNode.next = pre;
        pre = currentNode;
        currentNode = next;
      }
      return pre;
    }

    // console.log(reverseList(linkedList.head.next))

    function removeElements (head, val) {
      let resultNode = {};
      // let resultNode = new ListNode(0);
      resultNode.next = head;
      let cur = head;
      let pre = resultNode;
      while (cur) {
        if (cur.val === val) {
          pre.next = cur.next
        } else {
          pre = cur;
        }
        cur = cur.next;
      }
      return resultNode.next;
    }

    // console.log(removeElements(linkedList.head.next,1));

    function oddEvenList (head) {
      // 结点1作为奇数链的头 结点2作为偶数链的头
      // 从第3个点开始遍历，依次轮流附在奇、偶链的后面
      // 遍历完后，奇数链的尾连向偶链的头，偶链的尾为空， 返回奇数链的头
      if (!head) {
        return null;
      }
      let oddNode = head;
      let evenNode = head.next;
      let evenHead = evenNode;
      if (!evenNode) {
        return head;
      }
      // let i = 3, nextNode = evenNode.next;
      // while (nextNode) {
      //   if (i % 2) {
      //     oddNode.next = nextNode;
      //     oddNode = oddNode.next;
      //   } else {
      //     evenNode.next = nextNode;
      //     evenNode = evenNode.next;
      //   }
      //   nextNode = nextNode.next;
      //   i++;
      // }
      while (evenNode && evenNode.next) {
        // 下一个奇数   是偶数的下一个
        oddNode.next = evenNode.next;
        // 奇数节点后移到下一个
        oddNode = oddNode.next;

        // 下一个偶数节点  是已经后移的奇数节点下一个
        evenNode.next = oddNode.next;
        // 偶数节点后移
        evenNode = evenNode.next;
      }
      // evenNode.next = null;
      oddNode.next = evenHead;
      return head;
    }

    // console.log(oddEvenList(linkedList.head.next));

    function isPalindrome (head) {
      if (!head) {
        return true;
      }
      if (!head.next) {
        return true;
      }
      let mid = head,
      end = head.next;
      while (end && end.next) {
        mid.next.pre = mid;
        mid = mid.next;
        end = end.next.next;
      }
      let firstHalf = mid,
      secondHalf = mid.next;
      if (!end) {
        firstHalf = mid.pre;
      }
      while (secondHalf) {
        if (secondHalf.val !== firstHalf.val) {
          return false;
        }
        secondHalf = secondHalf.next;
        firstHalf = firstHalf.pre;
      }
      return true;
    }
    // console.log(isPalindrome(linkedList.head.next));


    class Node2 {
      constructor(val) {
        this.val = val;
        this.next = null;
        this.prev = null;
      }
    }
    class MyLinkedList2 {
      constructor() {
        this.head = {
          next: null,
          prev: null,
        };
        this.len = 0;
      }
      static createNode(val) {
        return new Node2(val);
      }
      addAtHead(val) {
        this.addAtIndex(0, val);
      }
      addAtTail(val) {
        this.addAtIndex(this.len, val);
      }
      addAtIndex(index, val) {
        if (index > this.len) {
          return;
        }
        let newNode = MyLinkedList2.createNode(val),
        node = this.head,
        i = 0;
        while (i < index) {
          node = node.next;
          i++;
        }
        newNode.next = node.next;
        newNode.prev = node;
        newNode.prev.next = newNode;
        if (newNode.next) {
          newNode.next.prev = newNode;
        }
        this.len++;
      }
      get(index) {
        if (index >= this.len) {
          return -1;
        }
        let node = this.head,
        i = 0;
        while (i <= index) {
          node = node.next;
          i++;
        }
        return node.val;
      }
      deleteAtIndex(index) {
        if (index >= this.len || index < 0) {
          return;
        }
        let node = this.head,
        i = 0;
        while (i < index) {
          node = node.next;
          i++;
        }
        node.next = node.next.next;
        this.len--;
      }
    }
    let linkedList2 = new MyLinkedList2();
    linkedList2.addAtHead(9);
    linkedList2.addAtTail(8);
    linkedList2.addAtTail(7);
    linkedList2.addAtTail(6);
    // linkedList2.addAtIndex(1,2);   //链表变为1-> 2-> 3
    // linkedList2.get(1);            //返回2
    // linkedList2.deleteAtIndex(1);  //现在链表是1-> 3
    // linkedList2.get(1);            //返回3
    console.log(linkedList2);

    function ListNode(val) {
      this.val = val;
      this.next = null;
    }

    // 迭代
    function mergeTwoLists (l1, l2) {
      const head = new ListNode(0);
      let temp = head;
      while (l1 && l2) {
        if (l1.val < l2.val) {
          temp.next = l1;
          l1 = l1.next;
        } else {
          temp.next = l2;
          l2 = l2.next;
        }
        temp = temp.next;
      }
      if (l1) {
        temp.next = l1;
      }
      if (l2) {
        temp.next = l2;
      }
      return head.next;
    }

    // 递归
    function mergeTwoLists (l1, l2) {
      if (!l1) {
        return l2;
      } else if (!l2) {
        return l1;
      } else if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
      } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
      }
    }

    function addTwoNumbers (l1, l2) {
      const head = new ListNode(0);
      let temp = head,
      ten = 0;
      while (l1 || l2) {
        let x = l1 ? l1.val : 0;
        let y = l2 ? l2.val : 0;
        let sum = ten + x + y;
        if (sum >= 10) {
          ten = 1;
          temp.next = new ListNode(sum - 10);
        } else {
          ten = 0;
          temp.next = new ListNode(sum);
        }
        temp = temp.next;
        if (l1) {
          l1 = l1.next;
        }
        if (l2) {
          l2 = l2.next;
        }
      }
      if (ten) {
        temp.next = new ListNode(1);
      }
      return head.next;
    }

    // console.log(addTwoNumbers(linkedList.head.next, linkedList2.head.next))



    function flatten (head) {
      if (!head) {
        return null;
      }
      const result = new Node(0, null, head, null);
      let temp = result;
      const stack = [head];
      while (stack.length) {
        let node = stack.pop();
        temp.next = node;
        node.prev = temp;
        if (node.next) {
          stack.push(node.next);
        }
        if (node.child) {
          stack.push(node.child);
          node.child = null;
        }
        temp = node;
      }
      result.next.prev = null;
      return result.next;
    }

    // console.log(flatten(linkedList2.head.next));


    function copyRandomList (head) {
      if (!head) {
        return null;
      }
      
    }

    function rotateRight (head, k) {
      if (!head) {
        return null;
      }
      let i = 1, curr = head;
      while (curr.next) {
        i++;
        curr = curr.next;
      }
      curr.next = head;
      let j = i - k % i;
      while (j) {
        curr = curr.next;
        j--;
      }
      let resultNode = curr.next;
      curr.next = null;
      return resultNode;
    }

    class MyHashSet {
      constructor() {

      }
      add(value) {

      }
      contains(value) {

      }
      remove(value) {

      }
    }

    function containsDuplicate (nums) {
      let mySet = new Set();
      for(let i = 0, length1 = nums.length; i < length1; i++){
        if (!mySet.has(nums[i])) {
          mySet.add(nums[i]);
        } else {
          return true;
        }
      }
      return false;
    }

    function singleNumber (nums) {
      let mySet = new Set();
      for(let i = 0, length1 = nums.length; i < length1; i++){
        if (mySet.has(nums[i])) {
          mySet.delete(nums[i]);
        } else {
          mySet.add(nums[i]);
        }
      }
      return [...mySet];
    }

    function intersection (nums1, nums2) {
      let _intersection = new Set(),
          setA = new Set(nums1),
          setB = new Set(nums2);
      for (let elem of setB) {
        if (setA.has(elem)) {
          _intersection.add(elem);
        }
      }
      return [..._intersection];
    }

    function isHappy (n) {
      let setN = new Set([n]);
      function sum (n) {
        let powSum = 0;
        while (n) {
          powSum = powSum + Math.pow(n % 10, 2);
          n = Math.trunc(n / 10);
        }
        return powSum;
      }
      while (n !== 1) {
        n = sum(n);
        if (setN.has(n)) {
          return false;
        } else {
          setN.add(n);
        }
      }
      return true;
    }

    function twoSum (nums, target) {
      let myMap = new Map();
      for(let i = 0, length1 = nums.length; i < length1; i++){
        if (myMap.has(target - nums[i])) {
          return [myMap.get(target - nums[i]), i];
        }
        myMap.set(nums[i], i);
      }
      return false;
    }

    function isIsomorphic (s, t) {
      let myMapS = new Map(),
          myMapT = new Map();
      for(let i = 0, length1 = s.length; i < length1; i++){
        if (myMapS.has(s[i]) || myMapT.has(t[i])) {

          // 如果不在同一个位置
          if (myMapS.get(s[i]) !== myMapT.get(t[i])) {
            return false;
          }
        }
        myMapS.set(s[i], i);
        myMapT.set(t[i], i);
      }
      return true;
    }

    function findRestaurant (list1, list2) {
      let mapA = new Map(),
          result = [],
          indexSum = 2000;
      list1.forEach((element, index) => {
        mapA.set(element, index);
      });
      list2.forEach((element, index) => {
        if (mapA.has(element)) {
          let sum = index + mapA.get(element);
          if (sum < indexSum) {
            indexSum = sum;
            result = [element];
          } else if (sum === indexSum) {
            result.push(element);
          }
        }
      });
      return result;
    }

    // console.log(findRestaurant(["Shogun","Tapioca Express","Burger King","KFC"],["KFC","Shogun","Burger King"]))


    function firstUniqChar (s) {
      let myMap = new Map();
      for (let i = 0; i < s.length; i++) {
        if (myMap.has(s[i])) {
          myMap.set(s[i], myMap.get(s[i]) + 1);
        } else {
          myMap.set(s[i], 1);
        }
      }
      for (let i = 0; i < s.length; i++) {
        if (myMap.get(s[i]) === 1) {
          return i;
        }
      }
      return -1;
    }

    function intersect (nums1, nums2) {
      let myMap1 = new Map(),
          result = [];
      for (let i = 0; i < nums1.length; i++) {
        if (myMap1.has(nums1[i])) {
          myMap1.set(nums1[i], myMap1.get(nums1[i]) + 1);
        } else {
          myMap1.set(nums1[i], 1);
        }
      }

      for(let i = 0, length1 = nums2.length; i < length1; i++){
        if (myMap1.has(nums2[i])) {
          switch (myMap1.get(nums2[i])) {
            case 0:
              myMap1.delete(nums2[i]);
              break;
            default:
              myMap1.set(nums2[i], myMap1.get(nums2[i]) - 1);
              result.push(nums2[i]);
              break;
          }
        }
      }
      return result;
    }

    function containsNearbyDuplicate (nums, k) {
      let myMap = new Map();
      for(let i = 0, length1 = nums.length; i < length1; i++){
        if (myMap.has(nums[i])) {
          if (i - myMap.get(nums[i]) <= k) {
            return true;
          }
        }
        myMap.set(nums[i], i);
      }
      return false;
    }

    function groupAnagrams (strs) {
      function sortStr (str) {
        return str.split('').sort().join('');
      }
      const myMap = new Map();
      for(let i = 0, length1 = strs.length; i < length1; i++){
        const key = sortStr(strs[i]);
        if (myMap.has(key)) {
          myMap.set(key, [...myMap.get(key), strs[i]]);
        } else {
          myMap.set(key, [strs[i]]);
        }
      }
      return Array.from(myMap.values());
    }

    // console.log(groupAnagrams(["eat", "tea", "tan", "ate", "nat", "bat"]));
    function kidsWithCandies (candies, extraCandies) {
      const MAX_VALUE = Math.max(...candies);
      return candies.map(item => {
        return item + extraCandies >= MAX_VALUE;
      })
    }


    function isValidSudoku (board) {
      const row = [],
            column = [],
            box = [];
      for (let i = 0; i < 9; i++) {
        row[i] = new Map();
        column[i] = new Map();
        box[i] = new Map();
      }
      for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
          if (board[i][j] !== '.') {
            if (row[i].has(board[i][j])) {
              return false;
            } else {
              row[i].set(board[i][j], j);
            }
            if (column[j].has(board[i][j])) {
              return false;
            } else {
              column[j].set(board[i][j], i);
            }
            const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);
            if (box[boxIndex].has(board[i][j])) {
              return false;
            } else {
              box[boxIndex].set(board[i][j], boxIndex);
            }
          }
        }
      }
      return true;
    }
    // isValidSudoku();

    function sumNums (n) {
      return n && sumNums(n - 1) + n;
    }

    function numJewelsInStones (J, S) {
      let jewelsSet = new Set(),
          result = 0;
      for (const i of J) {
        jewelsSet.add(i);
      }
      for (const i of S) {
        if (jewelsSet.has(i)) {
          result++;
        }
      }
      return result;
    }

    function lengthOfLongestSubstring (s) {
      let long = 0,
          j = 0, n = s.length,
          mySet = new Set();
      for (let i = -1; i < n; i++) {
        if (i != -1) {
          mySet.delete(s[i]);
        }
        while (j < n && !mySet.has(s[j])) {
          mySet.add(s[j]);
          j++;
        }
        long = long > mySet.size ? long : mySet.size;
      }
      return long > mySet.size ? long : mySet.size;
    }
    // console.log(lengthOfLongestSubstring("pwwkew"));

    function fourSumCount (A, B, C, D) {
      const mapAB = new Map(),
            mapCD = new Map(),
            N = A.length;
      function setMap (map, sum) {
        map.set(sum, map.get(sum) + 1 || 1);
      }
      for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          setMap(mapAB, A[i] + B[j]);
          setMap(mapCD, C[i] + D[j]);
        }
      }
      let count = 0;
      for (let [key, value] of mapAB) {
        if (mapCD.has(0 - key)) {
          count += value * mapCD.get(0 - key);
        }
      }
      return count;
    }

    function topKFrequent (nums, k) {
      const myMap = new Map();
      for (const num of nums) {
        if (myMap.has(num)) {
          myMap.set(num, myMap.get(num) + 1);
        } else {
          myMap.set(num, 1);
        }
      }
      const arr = [...myMap];
      arr.sort((a, b) => b[1] - a[1]);
      const result = [];
      for (let i = 0; i < k; i++) {
        result.push(arr[i][0]);
      }
      return result;
    }
    // console.log(topKFrequent([1,2], 2));

    class RandomizedSet {
      constructor() {
        this.myMap = new Map();
      }
      insert(val) {
        if(this.myMap.has(val)) {
          return false;
        } else {
          this.myMap.set(val, 1);
          return true;
        }
      }
      remove(val) {
        return this.myMap.delete(val);
      }
      getRandom() {
        const size = this.myMap.size;
        if (!size) {
          return false;
        }
        const random = Math.floor(Math.random() * size);
        const arr = Array.from(this.myMap.keys());
        return arr[random];
      }
    }

    function search (nums, target) {
      if (!nums || nums.length === 0) {
        return -1;
      }
      let left = 0,
          right = nums.length - 1,
          mid = Math.floor((left + right) / 2);
      if (nums[left] > target || nums[right] < target) {
        return -1;
      }
      while (left <= right) {
        if (nums[mid] === target) {
          return mid;
        }
        if (nums[mid] > target) {
          right = mid - 1;
          mid = Math.floor((left + right) / 2);
        }
        if (nums[mid] < target) {
          left = mid + 1;
          mid = Math.ceil((left + right) / 2);
        }
      }
      return -1;
    }

    // console.log(search([-1,0,3,5,9,12],13));

    function mySqrt (x) {
      if (x === 0 || x === 1) {
        return x;
      }
      let left = 1, right = x, mid = Math.floor(x / 2);
      while (left <= right) {
        if (mid**2 <= x && (mid + 1)**2 > x) {
          return mid;
        }
        if (mid**2 < x) {
          left = mid + 1;
        }
        if (mid**2 > x) {
          right = mid - 1;
        }
        mid = Math.floor((left + right) / 2);
      }
    }
    // console.log(mySqrt(15));

    function guessNumber (n) {
      let left = 1, right = n, mid = Math.floor(n / 2);
      while (left <= right) {
        if (guess(mid) === 0) {
          return mid;
        }
        if (guess(mid) === -1) {
          right = mid - 1;
        }
        if (guess(mid) === 1) {
          left = mid + 1;
        }
        mid = Math.floor((left + right) / 2);
      }
    }

    function search (nums, target) {
      let left = 0,
          right = nums.length - 1,
          mid = Math.floor(nums.length / 2);
      while (left <= right) {
        if (nums[mid] === target) {
          return mid;
        }
        if (nums[left] <= nums[mid]) {
          if (target >= nums[left] && target < nums[mid]) {
            right = mid - 1;
          } else {
            left = mid + 1;
          }
        }
        if (nums[mid] <= nums[right]) {
          if (target > nums[mid] && target <= nums[right]) {
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }
        mid = Math.floor((left + right) / 2);
      }
      return -1;
    }
    // console.log(search([4,5,6,7,0,1,2], 0));

    function solution (isBadVersion) {
      return function (n) {
        let left = 0,
            right = n,
            mid = Math.floor((left + right) / 2);
        while (left < right) {
          if (isBadVersion(mid)) {
            right = mid;
          } else {
            if (isBadVersion(mid + 1)) {
              return mid + 1;
            } else {
              left = mid + 1;
            }
          }
          mid = Math.floor((left + right) / 2);
        }
        if (isBadVersion(mid)) {
          return mid;
        }
        return -1;
      }
    }

    function findPeakElement (nums) {
      let left = 0,
          right = nums.length,
          mid = Math.floor((left + right) / 2);
      while (left < right) {
        if (nums[mid] < nums[mid + 1]) {
          left = mid + 1;
        } else {
          right = mid;
        }
        mid = mid = Math.floor((left + right) / 2);
      }
      return left;
    }
    // console.log(findPeakElement([1,0, -1, -2, 3, 4, 3]));

    function findMin (nums) {
      let left = 0,
          right = nums.length - 1,
          mid = Math.floor((left + right) / 2);
      if (nums[right] >= nums[left]) {
        return nums[left];
      }
      while (left <= right) {
        if (nums[mid] > nums[mid + 1]) {
          return nums[mid + 1];
        }
        if (nums[mid] < nums[mid - 1]) {
          return nums[mid];
        }
        if (nums[left] < nums[mid]) {
          left = mid + 1;
        } else {
          right = mid - 1;
        }
        mid = Math.floor((left + right) / 2);
      }
      return -1;
    }

    // console.log(findMin([3,1, 2]));

    function searchRange (nums, target) {
      let left = 0,
          right = nums.length - 1,
          mid = Math.floor((left + right) / 2);
      function range (mid) {
        let left = mid,
            right = mid;
        while (nums[left] === target) {
          left--;
        }
        while (nums[right] === target) {
          right++;
        }
        return [left + 1, right - 1];
      }
      while (left + 1 < right) {
        if (nums[mid] === target) {
          return range(mid);
        } else if (nums[mid] > target) {
          right = mid;
        } else {
          left = mid;
        }
        mid = Math.floor((left + right) / 2);
      }
      if (nums[left] === target) {
        return range(left);
      }
      if (nums[right] === target) {
        return range(right);
      }
      return [-1, -1];
    }
    // console.log(searchRange([5,7,7,8,8,10],11));

    function findClosestElements (arr, k, x) {
      let left = 0,
          right = arr.length - 1,
          mid = Math.floor((left + right) / 2);
      while (left + 1 < right) {
        const a = Math.abs(arr[mid] - x);
        const b = Math.abs(arr[mid + 1] - x);
        if (a === 0 || b === 0) {
          break;
        }
        if(a === b && b <= Math.abs(arr[right] - x)) {
          right = mid;
        } else if (b > a) {
          right = mid;
        } else {
          left = mid;
        }
        mid = Math.floor((left + right) / 2);
      }
      const result = [];
      let l = mid, r = mid + 1;
      console.log(l,r)
      while (result.length < k) {
        const a = Math.abs(arr[l] - x);
        const b = Math.abs(arr[r] - x);
        if (r > arr.length - 1 || a <= b) {
          result.unshift(arr[l]);
          l--;
        } else {
          result.push(arr[r]);
          r++;
        }
      }
      console.log(result)
      return result;
    }

    // findClosestElements([1,2,2,2,3,3],3,3);

    function spiralOrder (matrix) {
      if (!matrix.length) {
        return [];
      }
      let result = [],
          rowLen = matrix.length,
          columnLen = matrix[0].length,
          row = 0,
          column = 0,

          topBorder = 0,
          rightBorder = columnLen,
          bottomBorder = rowLen,
          leftBorder = 0,

          direct = [
            [0, 1],
            [1, 0],
            [0, -1],
            [-1, 0]
          ];
          d = 0;
      while (result.length < rowLen * columnLen) {
        result.push(matrix[row][column]);
        switch (d) {
          case 0:
            if (column + 1 >= rightBorder) {
              d = 1;
              topBorder++;
            }
            row = row + direct[d][0];
            column = column + direct[d][1];
            break;
          case 1:
            if (row + 1 >= bottomBorder) {
              d = 2;
              rightBorder--;
            }
            row = row + direct[d][0];
            column = column + direct[d][1];
            break;
          case 2:
            if (column - 1 < leftBorder) {
              d = 3;
              bottomBorder--;
            }
            row = row + direct[d][0];
            column = column + direct[d][1];
            break;
          default:
            if (row - 1 < topBorder) {
              d = 0;
              leftBorder++;
            }
            row = row + direct[d][0];
            column = column + direct[d][1];
            break;
        }
      }
      return result;
    }

    // console.log(spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]]));

    function findPeakElement (nums) {
      let left = 0,
          right = nums.length - 1,
          mid = Math.floor((left + right) / 2);
      while (left + 1 < right) {
        if (nums[mid] < nums[mid + 1]) {
          left = mid + 1;
        } else {
          right = mid;
        }
        mid = Math.floor((left + right) / 2);
      }
      return left;
    }
    // console.log(findPeakElement([2,1,2,3,4,5,6,1,2,3,2,1,0,3]));

    function myPow (x, n) {
      if (n === 0) {
        return 1;
      }
      if (n === 1) {
        return x;
      }
      if (n === -1) {
        return 1 / x;
      }
      let left = Math.floor(n / 2),
          right = n - left,
          half = myPow(x, left);

      return half * half * myPow(x, right - left);
    }
    // console.log(myPow(-2, 3));

    function isPerfectSquare (num) {
      let left = 0,
          right = num,
          mid = Math.floor((left + right) / 2);
      while (left <= right) {
        const sqrt = num / mid;
        if (sqrt === mid) {
          return true;
        } else if (mid < sqrt) {
          left = mid + 1;
        } else {
          right = mid - 1;
        }
        mid = Math.floor((left + right) / 2);
      }
      return false;
    }
    // console.log(isPerfectSquare(16));

    function nextGreatestLetter (letters, target) {
      const len = letters.length;
      if (target >= letters[len - 1] || target < letters[0]) {
        return letters[0];
      }
      let left = 0,
          right = len - 1,
          mid = Math.floor((left + right) / 2);
      while (left + 1 <= right) {
        if (letters[mid] <= target) {
          left = mid + 1;
        } else {
          right = mid;
        }
        mid = Math.floor((left + right) / 2);
      }
      return letters[left];
    }
    // console.log(nextGreatestLetter(["c", "f","f","f","f","f","f", "f"], 'd'));

    function findMin (nums) {
      // nums = [...new Set(nums)];
      let left = 0,
          right = nums.length - 1,
          mid = Math.floor((left + right) / 2);
      while (left < right) {
        if (nums[mid] > nums[right]) {
          left = mid + 1;
        } else if (nums[mid] < nums[right]) {
          right = mid;
        } else {
          right--;
        }
        mid = Math.floor((left + right) / 2);
      }
      return nums[left];
    }
    // console.log(findMin([3,3,1,3,3,3,3,3,3]))

    function twoSum (numbers, target) {
      let left = 0,
          right = numbers.length - 1,
          mid = Math.floor(left + (right - left) / 2),
          i = 0,
          j = 0;
      while (left < right) {
        if (numbers[mid] > target) {
          right = mid;
        } else {
          left = mid + 1;
        }
        mid = Math.floor(left + (right - left) / 2);
      }
      j = left;
      while (i < j) {
        if (numbers[i] + numbers[j] < target) {
          i++;
        } else if (numbers[i] + numbers[j] > target) {
          j--;
        } else {
          return [i + 1, j + 1]
        }
      }
      return [];
    }

    function findDuplicate (nums) {
      let len = nums.length,
          left = 1,
          right = len,
          mid = Math.floor(left + (right - left) / 2);
      while (left < right) {
        let count = 0;
        for (let i = 0; i < len; i++) {
          if (nums[i] <= mid) {
            count++;
          }
        }
        if (count > mid) {
          right = mid;
        } else {
          left = mid + 1;
        }
        mid = Math.floor(left + (right - left) / 2);
      }
      return left;
    }

    // console.log(findDuplicate([3,2,1,2,4,5,6,7,8,9,10]));

    function findMedianSortedArrays (nums1, nums2) {
      
    }
  </script>
</html>
